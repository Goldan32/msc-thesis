\chapter{Multicore Rust Project}

Before any application can be developed in Rust for this MCU, the state of Rust support needs to be properly assessed for both single and dual core STM32H7 devices. By the end of this chapter, a multi core Rust "Hello World" project should be ready as a starting point for more complex applications.

\section{Single core support}

\subsection{General structure}

As mentioned before, STM32 hardware has a relatively strong Rust support regarding MCU-s and their peripherals, even the development boards in some cases. But the typical project structure is very different from what was discussed in the previous chapter about C projects and using STMCubeIDE. The Rust crates that support embedded devices are layered hierarchically, first there is a crate required for every Cortex-M microcontroller: \mycode(cortex-m), then the \mycode{embedded-hal} crate expands upon that with functionalities commonly found in HAL drivers. Below that is a crate called \mycode{stm32-hal}, which is then expended upon by \mycode{stm32h7xx-hal} which can finally be used on the STM32H745 microcontroller, sadly with the twist that only the M7 core will function properly without doing some kind of workaround. Though not an official crate by ST there exists a BSP crate for the development board used in this project called \mycode{nucleo-h7xx}. This crate provides useful abstractions over the previous crate in the dependency chain, but as it will be discussed later, using this BSP crate would only complicate things in the long run for this project.

It is also worth mentioning that the \mycode{stm32h7xx-hal} crate depends on another crate called \mycode{stm32h7}. This crate provides type safe access to the peripherals of H7 series ST microcontrollers. These type of projects generate their register maps from SVD files using the \mycode{svd2rust} tool. The tool is maintained by the developers of the Rust language and is used extensively when creating support for a new embedded device.

\subsection{An embedded Rust project}

Rust projects are fairly lightweight compared to projects generated from some IDE like STMCubeIDE. For example here is the structure of a new project generated by the \mycode{cargo init} command.

\begin{lstlisting}[language=C,frame=single,float=!ht,label={lst:rust-project-structure},caption={Rust Project Structure}]
    .
    |-- Cargo.toml
    |-- src
        |-- main.rs

\end{lstlisting}

Essentially only 2 files were created. \mycode{Cargo.toml} will hold information about the project, such as its name and version, but it will also list all the dependencies. Build targets can also be defined in this file, it basically fills the role of a "project setting" or "project properties" window from an IDE. This file can be modified by hand and the changes will take effect on the next compilation, but some cargo commands will also modify it automatically. For example a dependency can be added by listing it under the \mycode{[dependencies]} section header and building the project, or by running the \mycode{cargo add <crate>} command, which will automatically list the dependency in the file. Some features can also be defined for these dependencies, the main one being their minimum required version, but soon some other ones will become important when the STM32 related crated will be added.

The other file is the \mycode{main.rs} source file that contains the entry point of the program, a main function. By default, this file contains a basic "Hello World" program, so the project can already be built and ran.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:rust-hello-world},caption={Rust Hello World Porgram}]
    fn main() {
        println!("Hello, world!");
    }
\end{lstlisting}

Of course this basic project is not going to work on a microcontroller without some major changes. Here are the necessary steps that need to be taken before a new Rust project produces a binary that can be loaded onto an MCU.

When we installed the Rust toolchain on a computer, it automatically detected the CPU-s architecture, and fledged a compiler specific to that. To compile to another architecture, we need to add another target to our toolchain. This can be done with the command \mycode{rustup target install thumbv7em-none-eabihf} which installs a compiler that can target ARM Cortex-M cores with floating point support. The target depends on the capabilities of the microcontroller, but in case of this project, both cores of the STM32H745 can use this toolchain.

A way to program the microcontroller is also needed. A Rust native tool is cargo-flash which can be installed with \mycode{cargo install cargo-flash}. It automatically detects how to program a microcontroller based on its type if it is supported. However once the project was built, any other way can be used to program the MCU. Further on, I will talk about challenges around programming this specific device.

Once our toolchain was expanded with the previous tools, we need to modify the basic project to use these tools. A new configuration file \mycode{.cargo/config} should be created. This is also a TOML file that configures the project, but instead of storing dependencies and higher level concepts, it will relate directly to the compilation phase. The new file will contain a line which selects the previously added target as the default one when building. Information about the linking phase can also be supplied here for example, in the \mycode{cortex-m} crate there is a linker script \mycode{link.x} which needs to be explicitly included in every project that uses this, or any other crate using it. Many other tweaks can be configured in this file, but these two are necessary for building a minimal working program. Here is a sample file that contains these two configurations.

\begin{lstlisting}[language=C,frame=single,float=!ht,label={lst:cargo-config-file},caption={Cargo Config File}]
    [build]
    target    = "thumbv7m-none-eabihf"
    rustflags = [ "-C", "link-arg=-Tlink.x" ]
\end{lstlisting}

Of course the basic linker script from will not be enough, a linker script specific to the MCU we intend to use must also be supplied. This can be done by creating a file called \mycode{memory.x} at the root of the project, and filling it with information about the memory mapping of the selected microcontroller. However in this case the linker script is already part of the \mycode{stm32h7xx-hal} crate, so it does not need to be created manually if we plan to use this crate.

With that done, we will need to add some necessary dependencies. As a \mycode{memory.x} linker script was not created manually, we must include the \mycode{stm32h7xx-hal} under as a dependency. Besides its minimal version, a feature set also needs to be specified here for this crate to work properly. Another necessity was already mentioned before, a panic handler needs to be created as any code can panic unexpectedly, and the program cannot quit without an underlying operating system. \mycode{panic-halt} is a crate that adds a default panic handler that puts the processor into a HALT state when the program running on it panics. So a working project for the M7 core should contain at least the following contents in its \mycode{Cargo.toml} file.

\begin{lstlisting}[language=C,frame=single,float=!ht,label={lst:cargo-toml},caption={Cargo.toml File of the Project}]
    [package]
    name = "blink"
    version = "0.1.0"
    edition = "2021"

    [dependencies]
    cortex-m = "0.7.7"
    cortex-m-rt = "0.7.3"
    panic-halt = "0.2.0"
    stm32h7xx-hal = {version = "0.14.0", features = ["stm32h747cm7"]}
\end{lstlisting}

The only thing left after this is writing valid code that does something, such as blinking an onboard LED. Notice that there was no step that involved code generation based on GUI tools as was the case in STMCubeIDE. This means that all configurations will need te be done directly in the code, which can sound scary, but the rich types and strict compiler of Rust will help us make sure that the hardware passes the smoke test when we turn it on for the first time.

The first step of writing embedded code is getting rid of the standard library crate and the traditional main function with the \mycode{#![no_std]} and \mycode{#![no_main]} directives. Of course the program will still need an entry point, and that is why the \mycode{cortex-m-rt} crate is included in the project. This crate provides the \mycode{#[entry]} directive that can mark a function as the entry point of the program. It can still be called main, but is must have the following signature.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:embedded-main},caption={Main Function in Embedded Rust}]
    #[entry]
    fn main() -> ! {
        loop {}
    }
\end{lstlisting}

This code snippet describes main as a function that takes no arguments and does not return at all. This is why only a loop is present in its body, the loop expression is a shorthand for an infinite loop in Rust.

To make a simple blinking program only two more things are required. First we need to have some method to measure the time between the toggles of an LED, then a function that can actually toggle the LED. The \mycode{cortex-m} crate contains a \mycode{delay\_ms()} function that will insert the appropriate amount of NOP assembly statements to the code to wait at least the specified amount of milliseconds. Interrupts and a timer peripheral could also be used, but at this point we only aim to create a minimal working application and using busy waits is much easier. For the LED-s to work we just need to take the \mycode{GPIOE} peripheral and split it into a structure of pins. Then we take the \mycode{pe1} pin, configure it into push-pull mode and it can be controlled with the \mycode{set\_high()} and \mycode{set\_high()} functions.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:embedded-hello-world},caption={Embedded Hello World (Blink) in Rust}]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use stm32h7xx_hal::{pac, prelude::*};
use panic_halt as _;

#[entry]
    fn main() -> ! {
        let cp = cortex_m::Peripherals::take().unwrap();
        let dp = pac::Peripherals::take().unwrap();

        let pwr = dp.PWR.constrain();
        let pwrcfg = pwr.freeze();

        let rcc = dp.RCC.constrain();
        let ccdr = rcc.sys_ck(100.MHz()).freeze(pwrcfg, &dp.SYSCFG);

        let gpioe = dp.GPIOE.split(ccdr.peripheral.GPIOE);

        // Configure PE1 as output.
        let mut led = gpioe.pe1.into_push_pull_output();

        // Get the delay provider.
        let mut delay = cp.SYST.delay(ccdr.clocks);

        loop {
            led.set_high();
            delay.delay_ms(500_u16);

            led.set_low();
            delay.delay_ms(500_u16);
        }

    }
\end{lstlisting}

One main difference in Rust compared to C is that peripherals are objects and can only be created or taken in a certain way instead of just creating a variable with the appropriate type. For example, we are forced to set power constraints to be able to set the system clock to a frequency, which in turn is needed to access the GPIO-s. Both the peripherals from the \mycode{cortex-m} and the \mycode{stm32h7xx-hal} crate are part of a singleton module. This is done deliberately so they are not taken more times than one by accident, which is very useful for single core applications, but may become bothersome with multicore usage. This is of course an open issue with the \mycode{cortex-m} crate and is yet to be assessed. \cite{MulticorePeripherals}

With all this, a simple, single core application is ready and we can start to research how it can be made to accommodate code for the other core. Loading the application is possible with the previously mentioned \mycode{cargo-flash} tool, though it will not be able to figure out the chip type, it can supplied as an argument.

\begin{lstlisting}[language=C,frame=single,float=!ht,label={lst:cargo-flash-1},caption={Flashing the Image with Cargo Flash}]
    cargo flash --chip STM32H745ZITx
\end{lstlisting}

\section{Multicore project structure}

This section discusses possible structures and hierarchies for a multicore project in Rust for the STM32H745 microcontroller.

\subsection{Separate projects for cores}

The first idea of a multicore project is to copy the structure of multicore C setup as closely as possible. This solution would require two completely separate projects for the two cores which would allow for great flexibility as the code would be loosely coupled between cores. Developing independent applications for the two cores would be the most comfortable this way. However a way for the two cores to communicate must also be included in a project like this, and that is most commonly done using some sort of shared memory. Defining shared memory sections requires the connection of the two projects on some level at least in the linking phase of compilation. As of writing this part of the essay, no project structured like this could be found that could support all the necessary features. This means that if this method of project organization is selected, besides making an example application, a framework also needs to be created to support the structure. This would not be impossible but would be questionable if it would fit into the time frame of the project, so it necessary to explore other ways of creating a multicore project structure.

\subsection{Single project for all cores}

At the other end of the spectrum, it is possible to compile code for both cores from a single project by modifying the linker script. This could be achieved by defining the entry point of the second core and and placing its code in the correct memory segment using the \mycode{memory.x} linker script. The advantage of this method over the previous one is that shared memory is easily defined and handled as there will not be separate compilation and linking for the two cores, it will be done in one go. There are also drawbacks however, for example the two cores can ever only use the same crates, as there is only one project so its dependencies cannot be changed for each core. On top of this, the usage of peripherals will run into the same problem discussed earlier. As the peripherals form a singleton module and there is only a way to "take" them but no way to "give" them, only one core will be able to access them safely. Finding a workaround for this issue without compromising safety is also a task that may run out of the time frame of the project.

Despite the drawbacks, one more advantage is that there is a very low level example project using this project structure from a prominent member of the embedded Rust community. \cite{DualCoreDemo} This example project does not use the \mycode{stm32h7xx-hal} crate get access to the peripherals but rather a crate called \mycode{stm32-ral}. This register access layer crate provides access to the peripheral registers of the microcontroller, so it circumvents the singleton limitation of HAL crates. However using this crate for a bigger project may not be feasible as more complex peripherals, for example the ethernet connector, can be difficult to use without drivers and only using the peripheral registers.

During this research, a half solution was found for this obstacle. By using both the \mycode{stm32h7xx-hal} and the \mycode{stm32-ral} crates, both cores can have access to the peripherals. The M7 core would use the HAL crate and the M4 core would use the registers to access the peripherals. This would introduce a limitation into further application development, as drivers would only be available for the M7 core. Still, the M4 core could access peripherals, and handling the less complex ones could be done using registers, while the M7 core would use the more complex ones with proper HAL drivers.

To create this project, we need to update the \mycode{Cargo.toml}, \mycode{memory.x} and \mycode{main.rs} files. \mycode{Cargo.toml} will receive the following line in its dependencies section.

\begin{lstlisting}[language=C,frame=single,float=!ht,label={lst:stm32-ral},caption={STM32 RAL in Cargo.toml}]
    stm32ral = { version = "0.8", features = ["stm32h747cm4"], default-features = false }
\end{lstlisting}

Notice that while the \mycode{stm32h7xx-hal} crate was added with \mycode{stm32h747cm7} features, the register access layer is added with \mycode{stm32h747cm4} features, as it will be used by the M4 core. The linker file will also needs to be modified, which means that is needs to be copied out from the HAL crate and included in our project as a file so it can be edited. Besides the default definitions in this file we need to define the stack, reset table and vector table for the second core. The flash area for the second core is already defined in the script, so as an extension we just need to populate it with the correct code. The stack of the second core can be defined as follows. For reference, the definition of the stack for the first core is also presented.

\begin{lstlisting}[language=C,frame=single,float=!ht,label={lst:link-starts},caption={Stack Definitions in Linker File}]
    _stack_start = ORIGIN(RAM) + LENGTH(RAM);
    _cpu2_stack_start = ORIGIN(SRAM2) + LENGTH(SRAM2);
\end{lstlisting}

To make sure that the reset and vector tables of the second core will be at the correct parts of the flash, the following code can be added to the \mycode{SECTIONS} block of the linker script.

\begin{lstlisting}[language=C,frame=single,float=!ht,label={lst:link-flash2},caption={Flash Definition of Second Core in Linker File}]
    .flash2 : ALIGN(4) {
        LONG(_cpu2_stack_start);
        KEEP(*(.flash2.reset_vector));
        KEEP(*(.flash2.vector_table));
        *(.flash2 .flash2.*);
        . = ALIGN(4);
    } > FLASH2
\end{lstlisting}

Finally, a main function can be created for the second core.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:embedded-main2},caption={Main Function of Second Core}]
    unsafe extern "C" fn main2() -> ! {
    write_reg!(rcc, RCC, AHB4ENR, GPIOBEN: Enabled);
    write_reg!(gpio, GPIOB, MODER, MODER0: Output, MODER14: Output);
    write_reg!(gpio, GPIOB, ODR, 0);
    loop {
        write_reg!(gpio, GPIOB, BSRR, BS0: 1);
        cortex_m::asm::delay(4_000_000);
        write_reg!(gpio, GPIOB, BSRR, BR0: 1);
        cortex_m::asm::delay(4_000_000);
    }
}

#[no_mangle]
#[link_section=".flash2.reset_vector"]
pub static CPU2_RESET_VECTOR: unsafe extern "C" fn() -> ! = main2;
\end{lstlisting}

The function itself initializes a GPIO and its clock, then toggles it every 4 million CPU cycles. The actual time of the delay will be determined by the frequency configured by the other core. Below the function the directives can be seen that will place the address of this function in the reset vector for the M4 core. While this solution could work well, there are some compromises, so it is worth investigating further in hopes of finding a better project structure.

\section{The microamp framework}

The microamp framework was developed recently as a framework for multicore embedded devices. It sort of combines the previous two approaches by providing a way to compile different codes for the two cores, but retaining the possibility of placing variables in shared memory. The framework provides two main functionalities. One of them is the \mycode{#[shared]} attribute, which can signal that a variable should be placed in shared memory. This also requires that some parts of the memory map must be marked as shared in the linker script, and the variable must also be static. The other main functionality is code sharing and division between the cores. By default, every code will be compiled and loaded onto both cores. However with attributes such as \mycode{#[cfg(core = "0")]} or the \mycode{cfg!(core = "0")} macro parts of the code can be directed to only be compiled to a specific core.

\subsection{Shared variables}

As already stated, shared variables can be declared the following way.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:shared-variable},caption={Shared Variable Example}]
    #[shared]
    static mut SHARED_VAR: u32 = 0;
\end{lstlisting}

The attribute does not affect the compile process directly as this variable will be present in the binary output for both cores, but possibly on different memory addresses. However here is where the microamp framework comes in. After the compilation of the first core is done the location of any variable marked as shared will be stored, and during the building of the second core binary, these location of these variables can be set to match the addresses found in the first image.

One thing to be aware of with shared variables that are defined this way is that their initial value is only written in memory during the flashing process. Warm or even cold resetting the microcontroller will not set these variables back to their initial values. This is an unintended consequence of optimizations by the compiler. The rest of the optimizations are useful for the project thus turning them off would not be beneficial in the long run. The easy fix to this issue is adding a line which sets this variable to the default value.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:shared-variable2},caption={Shared Variable Example With Default Value}]
    #[shared]
    static mut SHARED_VAR: u32 = 0;
    unsafe { SHARED_VAR = 0; }
\end{lstlisting}

Of course this default value can be assigned at other places of the code and most of the time only one of the cores need to set it.

As it can be seen in Listing~\ref{lst:share-variable2} accessing these variables from any core is obviously an unsafe action so rust forbids it outside of code blocks marked \mycode{unsafe}. We usually need unsafe blocks to directly access memory anyway, that does not mean these accesses cannot be made safe, it just means that the potential of memory access violations or data races are present, and the programmer should take extra care with these parts of the code. In the case of a single shared variable a semaphore would suffice for making its access safe. Ideally, a hardware semaphore should be used, but for the first proof-of-concept project, the \mycode{AtomicU8} type will work in almost all cases. The only time a software semaphore cannot work correctly is if the two cores request access in the same clock cycle. For a real embedded device that margin of error is not good enough, but for this example, it will work fine.

First, we have to declare another shared variable.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:sw-semaphore1},caption={Software Semaphore Variables}]
    const CORE0: u8 = 0;
    const CORE1: u8 = 1;
    const LOCKED: u8 = 2;

    #[shared]
    static SEMAPHORE: AtomicU8 = AtomicU8::new(CORE0);
\end{lstlisting}

Some constants are also defined to make the example easier to understand. Next, two constant variables are created, but the value of them will differ based on which core we are currently compiling for.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:sw-semaphore2},caption={Software Semaphore Core Specific Variables}]
    let (our_turn, next_core) = if cfg!(core = "0") {
        (CORE0, CORE1)
    } else {
        (CORE1, CORE0)
    };
\end{lstlisting}

With these variables the semaphore can now be locked and unlocked. Unlocking automatically gives the resource to the other core.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:sw-semaphore3},caption={Software Semaphore Locking and Unlocking}]
    while SEMAPHORE
        .compare_exchange(our_turn, LOCKED, Ordering::AcqRel, Ordering::Relaxed)
        .is_err()
    {
        // Busy wait if the lock is held by the other core
    }

    // Release the semaphore
    SEMAPHORE.store(next_core, Ordering::Release);
\end{lstlisting}

To protect a resource a simple mutex can be created. The mutex is enforced by a shared variable similar to the previously described semaphore. The resource guarded with this variable can be accessed by the same core multiple times in a row.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:sw-mutex1},caption={Mutex For a Variable}]
    const UNLOCKED: u8 = 0;
    const LOCKED: u8 = 1;

    #[shared]
    static mut CURRENT_VOLTAGE: f32 = 0.0;

    #[shared]
    static MUTEX: AtomicU8 = AtomicU8::new(UNLOCKED);
\end{lstlisting}

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:sw-mutex2},caption={Performing a Read Operation Using a Mutex}]
    while MUTEX
    .compare_exchange(UNLOCKED, LOCKED, Ordering::AcqRel, Ordering::Relaxed)
    .is_err()
    {}

    // MUTEX TAKEN
    let display_voltage;
    unsafe {
        display_voltage = CURRENT_VOLTAGE;
    }

    MUTEX.store(UNLOCKED, Ordering::Release);
    // MUTEX GIVEN
\end{lstlisting}

\subsection{Divergent code}

It is not a strange thing in Rust that compile time directives look similar to "active code" that will actually be translated to machine instructions. This is by design so the code becomes readable on a higher level, however makes the language harder to understand when dealing with low level compilation tasks. In this example project the infinite loop of the application will be fully different for the two cores.

\begin{lstlisting}[language=Rust,frame=single,float=!ht,style=customrust,label={lst:divergent-code},caption={Example of Diverging Code}]
    loop {
        match () {
            #[cfg(core = "0")]
            () => {
                writeln!(tx, "Hello World!\r\n").unwrap();
                while SEMAPHORE
                    .compare_exchange(our_turn, LOCKED, Ordering::AcqRel, Ordering::Relaxed)
                    .is_err() {}
                unsafe {if SHARED > 5 {delay_time = 1000_u16}}
                SEMAPHORE.store(next_core, Ordering::Release);
                led.set_high();
                delay.delay_ms(delay_time);

                led.set_low();
                delay.delay_ms(delay_time);
            }
            #[cfg(not(core = "0"))]
            () => {
                while SEMAPHORE
                    .compare_exchange(our_turn, LOCKED, Ordering::AcqRel, Ordering::Relaxed)
                    .is_err() {}
                unsafe {SHARED += 1;}
                SEMAPHORE.store(next_core, Ordering::Release);
                led2.set_high();
                delay.delay_ms(500_u16);

                led2.set_low();
                delay.delay_ms(500_u16);
            }
        }
    }
\end{lstlisting}

When this code is compiled, the M7 core will only contain the upper arm of the match expression and the M4 will get the lower arm. In this example program one LED is continually toggled by the M7 core, while another one is toggled by the M4 core. The M4 core increments the shared variable by one in every iteration, while the other core reads it every time. After 5 cycles of this, the blinking speed of the LED operated by the M7 core is reduced by a factor of 4. This indicates that the variable can be written by one of the cores and written by the other.

The first part of this code is the same for both cores, which in turn is the same as the code in the single core case. Both cores create an instance of the singleton peripherals, so they both can have unrestricted access. This is another area where data races need to be prevented by the programmer. In this case the cores never use the same GPIO port, the LED-s are operated are located on separate ones, but in the future, if the two cores do need to use the same peripheral, they will also need to be protected by a semaphore, ideally a hardware semaphore.

\section{Linker scripts}

There is one more thing missing for the dual-core program to function properly. The microamp framework requires a separate linker script called \mycode{core0.x}, \mycode{core1.x} etc., one for every core. This presents another problem for this project. The \mycode{link.x} linker script from the \mycode{embedded-hal} crate is special in the sense that it wants to include a linker file called \mycode{memory.x}. In simple cases this is not an issue as HAL crates usually provide this file and if not, we can create it in the root of our project. However the microamp framework does not require this the \mycode{memory.x} script, but separate ones like \mycode{core0.x}, which usually hold almost the same content as the \mycode{memory.x} script just a bit more customized for the specific core.

So the problem is that \mycode{link.x} requires a single \mycode{memory.x}, but we have \mycode{core0.x} and \mycode{core1.x} which hold similar content but differ in some places. For example, the \mycode{stm32h7xx-hal} crate requires that a \mycode{RAM} and a \mycode{FLASH} symbol is defined in one of the linker scripts of the project. However exactly these symbols need to differ for the two cores, so this definition cannot be at a common place.

The workaround this issue is as follows. In both \mycode{core0.x} and \mycode{core1.x} the memory and the \mycode{RAM} and \mycode{FLASH} symbols are defined at the start of the linker script. The memory map is taken directly from the \mycode{memory.x} file of the HAL crate. After these are defined, the \mycode{link.x} script can be included so it is part of the build process. This means that is can be removed from the \mycode{.cargo/config} file. As we know, the \mycode{link.x} script will try to include a \mycode{memory.x} file so it needs to exist, but cannot and does not need to hold any information, so in my case it is just an empty file. The rest of the core specific linker scripts is \mycode{SECTIONS} block which only differs at the very end where the reset and interrupt vectors are defined, as we have to make sure those go to the correct flashes.

The last thing we need to do is define a memory section that can be used as a shared memory. For this demonstration the \mycode{AXISRAM} memory was chosen. Both cores have read and write access to it so it can serve this purpose. The following lines should be added in the \mycode{SECTIONS} block to define the shared memory.

\begin{lstlisting}[language=C,frame=single,float=!ht,label={lst:link-shared},caption={Defining Shared Memory in Linker File}]
    .shared : ALIGN(8) {
        KEEP(microamp-data.o(.shared));
        . = ALIGN(8);
    } > AXISRAM
\end{lstlisting}

\section{Build flow}

The microamp framework is in alpha state so it requires the nightly version of the rust toolchain. Besides that, building the project is pretty simple using the \mycode{microamp} command.

\begin{lstlisting}[language=C,frame=single,float=!ht,label={lst:cargo-microamp},caption={Building a Dual Core Application with Microamp}]
    cargo +nightly microamp --bin blink --release
\end{lstlisting}

\section{Flashing}

Loading the program onto the MCU is no longer the most convenient using \mycode{cargo-flash} as we now have two binaries after a single build. Images that contain the code for one or both of the cores can be flashed into the MCU using an official GUI tool from ST called CubeProgrammer. Before flashing a tool called \mycode{srec_cat} is used to create a single image from the two core specific outputs. The unified image can then be flashed using the CubeProgrammer program. For a more automated flashing process, ST provides a command line utility called \mycode{st-flash} which is part of the STLink Tools program package /cite{STLinkTools}. However this program runs into an error when a flashing an image that covers the memory region of both cores. This error \cite{STFlashError} is already well documented and its fix will be the part of the next release cycle. Until then the STMCubeProgrammer GUI tool remains the most efficient way of loading our programs onto the microcontroller.
