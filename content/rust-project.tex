\chapter{Multicore Rust Project}

Before any application can be developed in Rust for this MCU, the state of Rust support needs to be properly assessed for both single and dual core STM32H7 devices. By the end of this chapter, a multi core Rust "Hello World" project should be ready as a starting point for more complex applications.

\section{Single core support}

\subsection{General structure}

As mentioned before, STM32 hardware has a relatively strong Rust support regarding MCU-s and their peripherals, even the development boards in some cases. But the typical project structure is very different from what was discussed in the previous chapter about C projects and using STMCubeIDE. The Rust crates that support embedded devices are layered hierarchically, first there is a crate required for every Cortex-M microcontroller: \mycode(cortex-m), then the \mycode{embedded-hal} crate expands upon that with functionalities commonly found in HAL drivers. Below that is a crate called \mycode{stm32-hal}, which is then expended upon by \mycode{stm32h7xx-hal} which can finally be used on the STM32H745 microcontroller, sadly with the twist that only the M7 core will function properly without doing some kind of workaround. Though not an official crate by ST there exists a BSP crate for the development board used in this project called \mycode{nucleo-h7xx}. This crate provides useful abstractions over the previous crate in the dependency chain, but as it will be discussed later, using this BSP crate would only complicate things in the long run for this project.

It is also worth mentioning that the \mycode{stm32h7xx-hal} crate depends on another crate called \mycode{stm32h7}. This crate provides type safe access to the peripherals of H7 series ST microcontrollers. These type of projects generate their register maps from SVD files using the \mycode{svd2rust} tool. The tool is maintained by the developers of the Rust language and is used extensively when creating support for a new embedded device.

\subsection{An embedded Rust project}

Rust projects are fairly lightweight compared to projects generated from some IDE like STMCubeIDE. For example here is the structure of a new project generated by the \mycode{cargo init} command.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    .
    |-- Cargo.toml
    |-- src
        |-- main.rs
    
\end{lstlisting}

Essentially only 2 files were created. \mycode{Cargo.toml} will hold information about the project, such as its name and version, but it will also list all the dependencies. Build targets can also be defined in this file, it basically fills the role of a "project setting" or "project properties" window from an IDE. This file can be modified by hand and the changes will take effect on the next compilation, but some cargo commands will also modify it automatically. For example a dependency can be added by listing it under the \mycode{[dependencies]} section header and building the project, or by running the \mycode{cargo add <crate>} command, which will automatically list the dependency in the file. Some features can also be defined for these dependencies, the main one being their minimum required version, but soon some other ones will become important when the STM32 related crated will be added.

The other file is the \mycode{main.rs} source file that contains the entry point of the program, a main function. By default, this file contains a basic "Hello World" program, so the project can already be built and ran.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    fn main() {
        println!("Hello, world!");
    }
\end{lstlisting}

Of course this basic project is not going to work on a microcontroller without some major changes. Here are the necessary steps that need to be taken before a new Rust project produces a binary that can be loaded onto an MCU.

When we installed the Rust toolchain on a computer, it automatically detected the CPU-s architecture, and fetched a compiler specific to that. To compile to another architecture, we need to add another target to our toolchain. This can be done with the command \mycode{rustup target install thumbv7em-none-eabihf} which installs a compiler that can target ARM Cortex-M cores with floating point support. The target depends on the capabilities of the microcontroller, but in case of this project, both cores of the STM32H745 can use this toolchain.

A way to program the microcontroller is also needed. A Rust native tool is cargo-flash which can be installed with \mycode{cargo install cargo-flash}. It automatically detects how to program a microcontroller based on its type if it is supported. However once the project was built, any other way can be used to program the MCU. Further on, I will talk about challenges around programming this specific device.

Once our toolchain was expanded with the previous tools, we need to modify the basic project to use these tools. A new configuration file \mycode{.cargo/config} should be created. This is also a TOML file that configures the project, but instead of storing dependencies and higher level concepts, it will relate directly to the compilation phase. The new file will contain a line which selects the previously added target as the default one when building. Information about the linking phase can also be supplied here for example, in the \mycode{cortex-m} crate there is a linker script \mycode{link.x} which needs to be explicitly included in every project that uses this, or any other crate using it. Many other tweaks can be configured in this file, but these two are necessary for building a minimal working program. Here is a sample file that contains these two configurations.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    [build]
    target    = "thumbv7m-none-eabihf"
    rustflags = [ "-C", "link-arg=-Tlink.x" ]
\end{lstlisting}

Of course the basic linker script from will not be enough, a linker script specific to the MCU we intend to use must also be supplied. This can be done by creating a file called \mycode{memory.x} at the root of the project, and filling it with information about the memory mapping of the selected microcontroller. However in this case the linker script is already part of the \mycode{stm32h7xx-hal} crate, so it does not need to be created manually if we plan to use this crate.

With that done, we will need to add some necessary dependencies. As a \mycode{memory.x} linker script was not created manually, we must include the \mycode{stm32h7xx-hal} under as a dependency. Besides its minimal version, a feature set also needs to be specified here for this crate to work properly. Another necessity was already mentioned before, a panic handler needs to be created as any code can panic unexpectedly, and the program cannot quit without an underlying operating system. \mycode{panic-halt} is a crate that adds a default panic handler that puts the processor into a HALT state when the program running on it panics. So a working project for the M7 core should contain at least the following contents in its \mycode{Cargo.toml} file.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    [package]
    name = "blink"
    version = "0.1.0"
    edition = "2021"
    
    [dependencies]
    cortex-m = "0.7.7"
    cortex-m-rt = "0.7.3"
    panic-halt = "0.2.0"
    stm32h7xx-hal = {version = "0.14.0", features = ["stm32h747cm7"]}
\end{lstlisting}

The only thing left after this is writing valid code that does something, such as blinking an onboard LED. Notice that there was no step that involved code generation based on GUI tools as was the case in STMCubeIDE. This means that all configurations will need te be done directly in the code, which can sound scary, but the rich types and strict compiler of Rust will help us make sure that the hardware passes the smoke test when we turn it on for the first time.

The first step of writing embedded code is getting rid of the standard library crate and the traditional main function with the \mycode{#![no_std]} and \mycode{#![no_main]} directives. Of course the program will still need an entry point, and that is why the \mycode{cortex-m-rt} crate is included in the project. This crate provides the \mycode{#[entry]} directive that can mark a function as the entry point of the program. It can still be called main, but is must have the following signature.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    #[entry]
    fn main() -> ! {
        loop {}
    }
\end{lstlisting}

This code snippet describes main as a function that takes no arguments and does not return at all. This is why only a loop is present in its body, the loop expression is a shorthand for an infinite loop in Rust.

To make a simple blinking program only two more things are required. First we need to have some method to measure the time between the toggles of an LED, then a function that can actually toggle the LED. The \mycode{cortex-m} crate contains a \mycode{delay\_ms()} function that will insert the appropriate amount of NOP assembly statements to the code to wait at least the specified amount of milliseconds. Interrupts and a timer peripheral could also be used, but at this point we only aim to create a minimal working application and using busy waits is much easier. For the LED-s to work we just need to take the \mycode{GPIOE} peripheral and split it into a structure of pins. Then we take the \mycode{pe1} pin, configure it into push-pull mode and it can be controlled with the \mycode{set\_high()} and \mycode{set\_high()} functions.

\begin{lstlisting}[language=C,frame=single,float=!ht]
#![no_main]
#![no_std]

use cortex_m_rt::entry;
use stm32h7xx_hal::{pac, prelude::*};
use panic_halt as _;

#[entry]
    fn main() -> ! {
        let cp = cortex_m::Peripherals::take().unwrap();
        let dp = pac::Peripherals::take().unwrap();

        let pwr = dp.PWR.constrain();
        let pwrcfg = pwr.freeze();

        let rcc = dp.RCC.constrain();
        let ccdr = rcc.sys_ck(100.MHz()).freeze(pwrcfg, &dp.SYSCFG);

        let gpioe = dp.GPIOE.split(ccdr.peripheral.GPIOE);

        // Configure PE1 as output.
        let mut led = gpioe.pe1.into_push_pull_output();

        // Get the delay provider.
        let mut delay = cp.SYST.delay(ccdr.clocks);

        loop {
            led.set_high();
            delay.delay_ms(500_u16);

            led.set_low();
            delay.delay_ms(500_u16);
        }

    }
\end{lstlisting}

One main difference in Rust compared to C is that peripherals are objects and can only be created or taken in a certain way instead of just creating a variable with the appropriate type. For example, we are forced to set power constraints to be able to set the system clock to a frequency, which in turn is needed to access the GPIO-s. Both the peripherals from the \mycode{cortex-m} and the \mycode{stm32h7xx-hal} crate are part of a singleton module. This is done deliberately so they are not taken more times than one by accident, which is very useful for single core applications, but may become bothersome with multicore usage. This is of course an open issue with the \mycode{cortex-m} crate and is yet to be assessed. \cite{MulticorePeripherals}

With all this, a simple, single core application is ready and we can start to research how it can be made to accommodate code for the other core. Loading the application is possible with the previously mentioned \mycode{cargo-flash} tool, though it will not be able to figure out the chip type, it can supplied as an argument.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    cargo flash --chip STM32H745ZITx
\end{lstlisting}

\section{Multicore project structure}

This section discusses possible structures and hierarchies for a multicore project in Rust for the STM32H745 microcontroller.

\subsection{Separate projects for cores}

The first idea of a multicore project is to copy the structure of multicore C setup as closely as possible. This solution would require two completely separate projects for the two cores which would allow for great flexibility as the code would be loosely coupled between cores. Developing independent applications for the two cores would be the most comfortable this way. However a way for the two cores to communicate must also be included in a project like this, and that is most commonly done using some sort of shared memory. Defining shared memory sections requires the connection of the two projects on some level at least in the linking phase of compilation. As of writing this part of the essay, no project structured like this could be found that could support all the necessary features. This means that if this method of project organization is selected, besides making an example application, a framework also needs to be created to support the structure. This would not be impossible but would be questionable if it would fit into the time frame of the project, so it necessary to explore other ways of creating a multicore project structure.

\subsection{Single project for all cores}

At the other end of the spectrum, it is possible to compile code for both cores from a single project by modifying the linker script. This could be achieved by defining the entry point of the second core and and placing its code in the correct memory segment using the \mycode{memory.x} linker script. The advantage of this method over the previous one is that shared memory is easily defined and handled as there will not be separate compilation and linking for the two cores, it will be done in one go. There are also drawbacks however, for example the two cores can ever only use the same crates, as there is only one project so its dependencies cannot be changed for each core. On top of this, the usage of peripherals will run into the same problem discussed earlier. As the peripherals form a singleton module and there is only a way to "take" them but no way to "give" them, only one core will be able to access them safely. Finding a workaround for this issue without compromising safety is also a task that may run out of the time frame of the project.

Despite the drawbacks, one more advantage is that there is a very low level example project using this project structure from a prominent member of the embedded Rust community. \cite{DualCoreDemo} This example project does not use the \mycode{stm32h7xx-hal} crate get access to the peripherals but rather a crate called \mycode{stm32-ral}. This register access layer crate provides access to the peripheral registers of the microcontroller, so it circumvents the singleton limitation of HAL crates. However using this crate for a bigger project may not be feasible as more complex peripherals, for example the ethernet connector, can be difficult to use without drivers and only using the peripheral registers.

During this research, a half solution was found for this obstacle. By using both the \mycode{stm32h7xx-hal} and the \mycode{stm32-ral} crates, both cores can have access to the peripherals. The M7 core would use the HAL crate and the M4 core would use the registers to access the peripherals. This would introduce a limitation into further application development, as drivers would only be available for the M7 core. Still, the M4 core could access peripherals, and handling the less complex ones could be done using registers, while the M7 core would use the more complex ones with proper HAL drivers.

To create this project, we need to update the \mycode{Cargo.toml}, \mycode{memory.x} and \mycode{main.rs} files. \mycode{Cargo.toml} will receive the following line in its dependencies section.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    stm32ral = { version = "0.8", features = ["stm32h747cm4"], default-features = false }
\end{lstlisting}

Notice that while the \mycode{stm32h7xx-hal} crate was added with \mycode{stm32h747cm7} features, the register access layer is added with \mycode{stm32h747cm4} features, as it will be used by the M4 core. The linker file will also needs to be modified, which means that is needs to be copied out from the HAL crate and included in our project as a file so it can be edited. Besides the default definitions in this file we need to define the stack, reset table and vector table for the second core. The flash area for the second core is already defined in the script, so as an extension we just need to populate it with the correct code. The stack of the second core can be defined as follows. For reference, the definition of the stack for the first core is also presented.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    _stack_start = ORIGIN(RAM) + LENGTH(RAM);
    _cpu2_stack_start = ORIGIN(SRAM2) + LENGTH(SRAM2);
\end{lstlisting}

To make sure that the reset and vector tables of the second core will be at the correct parts of the flash, the following code can be added to the \mycode{SECTIONS} block of the linker script.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    .flash2 : ALIGN(4) {
        LONG(_cpu2_stack_start);
        KEEP(*(.flash2.reset_vector));
        KEEP(*(.flash2.vector_table));
        *(.flash2 .flash2.*);
        . = ALIGN(4);
    } > FLASH2
\end{lstlisting}

Finally, a main function can be created for the second core.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    unsafe extern "C" fn main2() -> ! {
    write_reg!(rcc, RCC, AHB4ENR, GPIOBEN: Enabled);
    write_reg!(gpio, GPIOB, MODER, MODER0: Output, MODER14: Output);
    write_reg!(gpio, GPIOB, ODR, 0);
    loop {
        write_reg!(gpio, GPIOB, BSRR, BS0: 1);
        cortex_m::asm::delay(4_000_000);
        write_reg!(gpio, GPIOB, BSRR, BR0: 1);
        cortex_m::asm::delay(4_000_000);
    }
}

#[no_mangle]
#[link_section=".flash2.reset_vector"]
pub static CPU2_RESET_VECTOR: unsafe extern "C" fn() -> ! = main2;
\end{lstlisting}

The function itself initializes a GPIO and its clock, then toggles it every 4 million CPU cycles. The actual time of the delay will be determined by the frequency configured by the other core. Below the function the directives can be seen that will place the address of this function in the reset vector for the M4 core. While this solution could work well, there are some compromises, so it is worth investigating further in hopes of finding a better project structure.

\section{The microamp framework}


