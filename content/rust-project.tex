\chapter{Multicore Rust Project}

Before any application can be developed in Rust for this MCU, the state of Rust support needs to be properly assessed for both single and dual core STM32H7 devices. By the end of this chapter, a multi core Rust "Hello World" project should be ready as a starting point for more complex applications.

\section{Single core support}

\subsection{General structure}

As mentioned before, STM32 hardware has a relatively strong Rust support regarding MCU-s and their peripherals, even the development boards in some cases. But the typical project structure is very different from what was discussed in the previous chapter about C projects and using STMCubeIDE. The Rust crates that support embedded devices are layered hierarchically, first there is a crate required for every Cortex-M microcontroller: \mycode(cortex-m), then the \mycode{embedded-hal} crate expands upon that with functionalities commonly found in HAL drivers. Below that is a crate called \mycode{stm32-hal}, which is then expended upon by \mycode{stm32h7xx-hal} which can finally be used on the STM32H745 microcontroller, sadly with the twist that only the M7 core will function properly without doing some kind of workaround. Though not an official crate by ST there exists a BSP crate for the development board used in this project called \mycode{nucleo-h7xx}. This crate provides useful abstractions over the previous crate in the dependency chain, but as it will be discussed later, using this BSP crate would only complicate things in the long run for this project.

It is also worth mentioning that the \mycode{stm32h7xx-hal} crate depends on another crate called \mycode{stm32h7}. This crate provides type safe access to the peripherals of H7 series ST microcontrollers. These type of projects generate their register maps from SVD files using the \mycode{svd2rust} tool. The tool is maintained by the developers of the Rust language and is used extensively when creating support for a new embedded device.

\subsection{An embedded Rust project}

Rust projects are fairly lightweight compared to projects generated from some IDE like STMCubeIDE. For example here is the structure of a new project generated by the \mycode{cargo init} command.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    .
    ├── Cargo.toml
    └── src
        └── main.rs
    
\end{lstlisting}

Essentially only 2 files were created. \mycode{Cargo.toml} will hold information about the project, such as its name and version, but it will also list all the dependencies. Build targets can also be defined in this file, it basically fills the role of a "project setting" or "project properties" window from an IDE. This file can be modified by hand and the changes will take effect on the next compilation, but some cargo commands will also modify it automatically. For example a dependency can be added by listing it under the \mycode{[dependencies]} section header and building the project, or by running the \mycode{cargo add <crate>} command, which will automatically list the dependency in the file. Some features can also be defined for these dependencies, the main one being their minimum required version, but soon some other ones will become important when the STM32 related crated will be added.
