\chapter{Multicore C Projects}

To create a usable multicore Rust project, a good starting point is studying C language projects created by the official tools of the manufacturer.

\section{Project structure}

Creating C language projects for the STM32H745 microcontroller can be done in the official IDE of STMicroelectronics which is called STMCubeIDE. The software is Eclipse based and can be used to generate empty or example projects, program, and debug the code on the hardware. This is also true for multicore projects, as there are now example projects that use both cores of a H7 series microcontroller. \cite{CExamples}

Creating a dual-core project in STMCubeIDE is similar to how one would create a normal project. By selecting a H7 series MCU not one but three connected projects are generated. A project similar to a single core one will be created for both the M7 and the M4 core. These projects can almost function as standalone projects, they can have their own source files, header files and references. These projects also have a separate \mycode{main.c} file which contains the entry point of the current core. They also both contain builder files, linker files and output folders, so essentially they can be built separately. By default, programming and debugging is also done with these separate projects, so when the IDE is used the cores are programmed one-by-one. Also as a limitation of the software only one of the two cores can be effectively debugged at a time, while the other one either runs or is in a HALT state.

The project is a wrapper for the previous two that rests above them in a hierarchical sense. It can also contain common code that can be referenced and shared from the core-specific projects. Most of the drivers can reside in this project, as regarding peripherals, the M7 and M4 cores are similar. The wrapper project also contains parts of the code that directly refer to dual-core functionalities, for example definitions of some memory locations and even some code regarding dual-core boot can be found there.

In STM32 projects, lots of code around setting up the peripherals is generated during project creation. This is no different in a dual-core project. Setting the function of each pin of the MCU can be done with a GUI, which then generated the code that will configure those pins correctly. The peripherals can be further configured in this GUI by enabling them, an initialization code will be added to the \mycode{main.c} source file of  one of the core-specific projects. In dual-core projects, the core that initializes a peripheral can be selected separately for each one, while also allowing both cores to use the same peripherals when one is enabled for both of them.

Besides the pinout configuration, the clock configuration can also be set in this GUI. This is especially helpful if our project requires different clocks for different clock domains. The clock settings can be configured in a hierarchical graphical interface where the sources and multiplications are visualized on a flow-control diagram. Clock signals for certain domains can even be turned off to save power, if none of the corresponding peripherals are used.

\section{An example project}

To fully understand the intended use of this dual-core MCU, we must take a look at a simple example project. This will give us a clear picture of how the microcontroller starts, peripherals are handled, and how the two cores communicate. The project this essay will take a closer look at is an example project from ST that uses message buffers from FreeRTOS to demonstrate communication between the two cores. \cite{CDemo}

\subsection{General description}

After the initialization phase, the M7 core will send data using message buffers. The data will be received by the M4 core which is not using an RTOS but running a bare metal application, though the FreeRTOS header will still need to be included to have access to its message buffer type. There is no communication in the other direction. This communication requires that the message buffer is declared in a shared memory which is accessible to both cores. Additionally the address of the buffer must be known to be the same at compile time for both cores. The data received by the M4 core will be checked for correctness, and if found correct, LED1 will be toggled. In case of an error LED2 will be set and the M4 core will enter an empty infinite loop. This operation takes place every 500 milliseconds. While M4 core busy waits for data in the message buffer the M7 core only sends the data after a 500 millisecond delay in every iteration.

\subsection{Initialization phase}

The initialization of the M4 core is more trivial than that of the M7 as the M4 handles the setup of the peripherals used. This is usually the case in these type of projects, and it is a good practice to have a controller core which can control peripherals and event the other core in the early stages of the application.

Firstly, the L1 data and instruction cache is enabled for the M7 core. The dangers of using a non shared cache should be kept in mind when creating projects that implement communication between the cores. The obvious solution is to invalidate the cache before reading or writing data to shared memory addresses, however on this MCU another, more convenient solution is also possible and used in this example. The next step is configuring the MPU (Memory Protection Unit). This peripheral, if set up correctly, can ensure correct cache contents by setting some regions of memory as non-cachable. The MPU can be configured using an MPU initialization struct. Its most important fields in this example are \mycode{IsCacheable} and \mycode{IsShareable}, and of course the selected region must also be given in this struct. The shared variables will be located in the \mycode{D3\_SRAM} so it is set to be non-cachable and shareable in this example.

While this is happening, the M4 core also starts and as it lacks cache and the MPU is handled by the other core, it starts to initialize its own variables and a hardware semaphore that will be used for inter-core communication.
