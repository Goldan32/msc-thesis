\chapter{Multicore C Projects}

To create a usable multicore Rust project, a good starting point is studying C language projects created by the official tools of the manufacturer.

\section{Project Structure}

Creating C language projects for the STM32H745 microcontroller can be done in the official IDE of STMicroelectronics which is called STMCubeIDE. The software is Eclipse based and can be used to generate empty or example projects, program, and debug the code on the hardware. This is also true for multicore projects, as there are now example projects that use both cores of a H7 series microcontroller \cite{CExamples}.

Creating a dual-core project in STMCubeIDE is similar to how one would create a normal project. By selecting an H7 series MCU, not one but three connected projects are generated. A project similar to a single-core one will be created for both the M7 and the M4 core. These projects can almost function as standalone projects, they can have their source files, header files, and references. These projects also have a separate \mycode{main.c} file which contains the entry point of the current core. They also both contain builder files, linker files, and output folders, so essentially they can be built separately. By default, programming and debugging are also done with these separate projects, so when the IDE is used the cores are programmed one by one. Also as a limitation of the software, only one of the two cores can be effectively debugged at a time, while the other one either runs or is in a HALT state.

The project is a wrapper for the previous two that rests above them in a hierarchical sense. It can also contain common code that can be referenced and shared from the core-specific projects. Most of the drivers can reside in this project, as regarding peripherals, the M7 and M4 cores are similar. The wrapper project also contains parts of the code that directly refer to dual-core functionalities, for example, definitions of some memory locations and even some code regarding dual-core boot can be found there.

In STM32 projects, lots of code around setting up the peripherals is generated during project creation. This is no different in a dual-core project. Setting the function of each pin of the MCU can be done with a GUI, which then generates the code that will configure those pins correctly. The peripherals can be further configured in this GUI by enabling them, an initialization code will be added to the \mycode{main.c} source file of one of the core-specific projects. In dual-core projects, the core that initializes a peripheral can be selected separately for each one, while also allowing both cores to use the same peripherals when one is enabled for both of them.

Besides the pinout configuration, the clock configuration can also be set in this GUI. This is especially helpful if our project requires different clocks for different clock domains. The clock settings can be configured in a hierarchical graphical interface where the sources and multiplications are visualized on a flow-control diagram. Clock signals for certain domains can even be turned off to save power if none of the corresponding peripherals are used.

\section{An Example Project}

To fully understand the intended use of this dual-core MCU, we must take a look at a simple example project. This will give us a clear picture of how the microcontroller starts, how peripherals are handled, and how the two cores communicate. The project this essay will take a closer look at is an example project from ST that uses message buffers from FreeRTOS to demonstrate communication between the two cores \cite{CDemo}.

\subsection{General description}

After the initialization phase, the M7 core will send data using message buffers. The data will be received by the M4 core which is not using an RTOS but running a bare metal application, though the FreeRTOS header will still need to be included to have access to its message buffer type. There is no communication in the other direction. This communication requires that the message buffer is declared in a shared memory which is accessible to both cores. Additionally, the address of the buffer must be known to be the same at compile time for both cores. The data received by the M4 core will be checked for correctness, and if found correct, LED1 will be toggled. In case of an error, LED2 will be set and the M4 core will enter an empty infinite loop. This operation takes place every 500 milliseconds. While M4 core busy waits for data in the message buffer the M7 core only sends the data after a 500 millisecond delay in every iteration.

\subsection{Initialization phase}

The initialization of the M4 core is more trivial than that of the M7 as the M4 handles the setup of the peripherals used. This is usually the case in these types of projects, and it is a good practice to have a controller core that can control peripherals and event the other core in the early stages of the application.

Firstly, the L1 data and instruction cache are enabled for the M7 core. The dangers of using a non-shared cache should be kept in mind when creating projects that implement communication between the cores. The obvious solution is to invalidate the cache before reading or writing data to shared memory addresses, however, on this MCU another, more convenient solution is also possible and used in this example. The next step is configuring the MPU (Memory Protection Unit). This peripheral, if set up correctly, can ensure correct cache contents by setting some regions of memory as non-cachable. The MPU can be configured using an MPU initialization struct. Its most important fields in this example are \mycode{IsCacheable} and \mycode{IsShareable}, and of course, the selected region must also be given in this struct. The shared variables will be located in the \mycode{D3\_SRAM} so it is set to be non-cachable and shareable in this example.

While this is happening, the M4 core also starts and as it lacks cache and the MPU is handled by the other core, it starts to initialize its own variables and a hardware semaphore that will be used for inter-core communication. After that, the M4 core puts itself into deep sleep mode, to wait for the other core while it finishes the initialization of the common peripherals.

After configuring the MPU and its own cache the M7 core will busy wait for the M4 core to go into a deep sleep state by continuously reading a register that stores information about the clock domain of the other core. When the other core is properly HALT-ed, the M7 can continue with the initialization of peripherals used by both cores. It will first setup the Hardware Abstraction Layer system, then will go on to initialize the clock system. In this case, the frequency is set to 400 MHz and half of that for the M4 core, but this part of the code is generated based on the GUI settings described already.

Finally, the message buffer is created on the M7 core, and the M4 core can be released from the sleep state. The M7 core will enable the clock of the domain where the previously mentioned hardware semaphore is located, then takes and releases the semaphore to wake up the other core. After this, a FreeRTOS task is created and the scheduler is started. After waking up, the M4 core will initialize the 2 LEDs it will use and enters into its infinite loop.

\subsection{Running phase}

There is only one task scheduled to run on the M7 core. This task simply creates a string that contains a number that is incremented after every iteration. This number is then placed into the message buffer and the task requests a 500 ms delay. This is the time the other core has for reading the value, as after this the buffer is reset by the M7 core. The M4 core starts with creating a string in local memory which will be compared to the one received, by having a similar local counter that gets incremented after every read from the buffer. After this, the M4 core busy waits until some data is placed in the message buffer, and immediately reads it once it arrives. It then compares it to the locally created string and if the values match, it toggles LED1 and if they do not, it goes into an error handler function. This function turns off LED1 and turns on LED2 to signal the error, then goes into an empty infinite loop. This loop of course could be modified to handle the error, but that is out of the scope of this study.
