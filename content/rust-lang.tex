\chapter{The Rust Programming Language}

This chapter is a brief introduction of the Rust programming language, and its most important features in context of this thesis.

\section{A compiled system programming language}

Officially Rust is considered a system programming language which means that its primary function is performance and ease of access to the hardware while still providing higher level programming concepts such as data structures to hold and organize data. \cite{SystemProgrammingLanguageWikipedia} For example, in Rust we can find a dynamic string type, but may also choose to take it as a byte array and manipulate the data that way.

Much like C and C++, Rust programs can only be run after they have been compiled into a binary. The aforementioned higher level concepts only exist at compile time so the binary program can be as efficient as possible. This will be true for all further concepts explained in this section, the resulting binaries from a C and Rust program are comparable both in size and execution speed, its just that the Rust compiler is more sophisticated than the C compiler.

\section{Type system}

\subsection{Types on the stack}

\subsubsection{Simple types}

These are the very basic types of Rust representing numbers, booleans and characters. Unlike in C, the size of the following types is not implementation dependent.

For representing numbers one can use \mycode{u8}, \mycode{u16}, \mycode{u32}, \mycode{u64}, \mycode{u128} and \mycode{usize} for representing unsigned integers, where the last one will use as many bits as the platform the code is compiled for (usually 32 or 64). Exchanging the \mycode{u} for an \mycode{i} in these types gives us the signed integer types.

Floating point numbers can be either stored using the \mycode{f32} or the \mycode{f64} type, this is similar to \mycode{float} and \mycode{double} in C.

Characters are represented in memory by 4 bytes to accommodate encodings up to UTF-8.

Rust also has a boolean type which is important for control flow, for example the \mycode{if} expression only allows a boolean expression in its header.

\subsubsection{Enums and Structs}

It is often said that Rust has an algebraic type system. What this mainly refers to is that all the available types can be combined in two ways. A struct will contain every type from its definition at the same time, while an enum will always evaluate to one of the types listed in its definition.

Enums and Structs also count as complete types which means that unlike in C, they cannot be represented as their underlying types by clever pointer arithmetics.

While structs behave mostly the same way as structs in C or classes in C++, enums are different from these common languages. For example an enum could be created for the purpose of representing color encoding types: RGB and hex codes.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    enum ColorFormat {
        RGB,
        HexCode
    }
\end{lstlisting}

In Rust we can go further, and attach relevant data directly to the enum values.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    enum ColorFormat {
        RGB(u8, u8, u8),
        HexCode(String)
    }
\end{lstlisting}

This way when a \mycode{ColorFormat} type is passed to a function, it can determine the incoming color format and also access the color itself. In addition to this, the compiler will check if this function does something with each of the enums it can receive, and fails the compilation if, for example \mycode{HexCode} type of color format is not handled.

\subsection{Types on the heap}

These are the types where ownership and references are important questions. A good example would be a string, where multiple parts of our code would like to modify or read the value, but ideally we only want one owner that is responsible for freeing up the memory used when the string is not needed anymore. Most of the types that contain data on the heap are part of the standard library of Rust. These include the aforementioned strings and some containers like \mycode{Vector}. How rust handles these data types will be discussed further on.

\subsection{Type conversions}

There are no implicit conversions between types in Rust. If we have a function in C that expects a \mycode{uint32\_t} as an argument and we try to pass it a variable of \mycode{uint16\_t} type, we may not even get a warning from the compiler and certainly not an error, as implicit type conversion is a part of C and C++. In Rust however, passing a \mycode{u16} type variable to a function that expects the \mycode{u32} type will result in a compile error. The compiler signals this inconsistency and suggests a solution.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    error[E0308]: mismatched types
    --> src/main.rs:7:15
     |
   7 |     print_u32(mynum);
     |     --------- ^^^^^ expected `u32`, found `u16`
     |     |
     |     arguments to this function are incorrect
     |
   note: function defined here
    --> src/main.rs:1:4
     |
   1 | fn print_u32(num: u32) {
     |    ^^^^^^^^^ --------
   help: you can convert a `u16` to a `u32`
     |
   7 |     print_u32(mynum.into());
     |                    +++++++
   
   For more information about this error, try `rustc --explain E0308`.
\end{lstlisting}

When we try to reverse the types in our example, C issues a warning about truncating integers, but still many programmers can just ignore this warning and assume the data is properly sanitized. Rust obviously will not let a code compile with integer truncation, but the solution is a bit more complex this time, because a possibility is present that the value does not fit in the smaller type.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    error[E0308]: mismatched types
    --> src/main.rs:7:15
     |
   7 |     print_u16(mynum);
     |     --------- ^^^^^ expected `u16`, found `u32`
     |     |
     |     arguments to this function are incorrect
     |
   note: function defined here
    --> src/main.rs:1:4
     |
   1 | fn print_u16(num: u16) {
     |    ^^^^^^^^^ --------
   help: you can convert a `u32` to a `u16` and panic if the converted value doesn't fit
     |
   7 |     print_u16(mynum.try_into().unwrap());
     |                    ++++++++++++++++++++
   
   For more information about this error, try `rustc --explain E0308`.
\end{lstlisting}

In this case the compiler suggests that we use \mycode{.unwrap\(\)}, which terminates the program if the previous function in the chain returned an error. However it is also possible to branch from the error, do something with the provided value and then even try to convert again to the smaller type, for example this would be one way to implement integer saturation.

\begin{lstlisting}[language=C,frame=single,float=!ht]
    fn print_u16(num: u16) {
        println!("{num}");
    }

    fn main() {
        let mynum: u32 = 66000;
        print_u16(match mynum.try_into() {
            Ok(val) => val,
            Err(_) => u16::MAX
        });
    }
\end{lstlisting}

Having restrictions like this can prevent the programmer from misinterpreting data in a function as it will always be in the smallest type possible that fits it without errors.

\section{Memory safety}

\subsection{Ownership}

\subsection{References (borrowing)}

\subsection{Lifetimes}




\section{Error handling}

\subsection{\mycode{Result} type}

\subsection{\mycode{panic!} macro}
